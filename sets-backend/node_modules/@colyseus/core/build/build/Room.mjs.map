{"version":3,"file":"Room.mjs","sources":["../Room.mjs"],"sourcesContent":["import msgpack from 'notepack.io';\nimport { decode } from '@colyseus/schema';\nimport Clock from '@gamestdio/timer';\nimport { EventEmitter } from 'events';\nimport { NoneSerializer } from './serializer/NoneSerializer.mjs';\nimport { SchemaSerializer } from './serializer/SchemaSerializer.mjs';\nimport { Protocol, ErrorCode, getMessageBytes } from './Protocol.mjs';\nimport { spliceOne, Deferred } from './Utils.mjs';\nimport { debugAndPrintError } from './Debug.mjs';\nimport { ServerError } from './errors/ServerError.mjs';\nimport { ClientState } from './Transport.mjs';\n\nconst DEFAULT_PATCH_RATE = 1000 / 20; // 20fps (50ms)\nconst DEFAULT_SIMULATION_INTERVAL = 1000 / 60; // 60fps (16.66ms)\nconst noneSerializer = new NoneSerializer();\nconst DEFAULT_SEAT_RESERVATION_TIME = Number(process.env.COLYSEUS_SEAT_RESERVATION_TIME || 15);\nvar RoomInternalState;\n(function (RoomInternalState) {\n    RoomInternalState[RoomInternalState[\"CREATING\"] = 0] = \"CREATING\";\n    RoomInternalState[RoomInternalState[\"CREATED\"] = 1] = \"CREATED\";\n    RoomInternalState[RoomInternalState[\"DISCONNECTING\"] = 2] = \"DISCONNECTING\";\n})(RoomInternalState || (RoomInternalState = {}));\nclass Room {\n    get locked() {\n        return this._locked;\n    }\n    get metadata() {\n        return this.listing.metadata;\n    }\n    listing;\n    clock = new Clock();\n    roomId;\n    roomName;\n    maxClients = Infinity;\n    patchRate = DEFAULT_PATCH_RATE;\n    autoDispose = true;\n    state;\n    presence;\n    clients = [];\n    internalState = RoomInternalState.CREATING;\n    /** @internal */\n    _events = new EventEmitter();\n    // seat reservation & reconnection\n    seatReservationTime = DEFAULT_SEAT_RESERVATION_TIME;\n    reservedSeats = {};\n    reservedSeatTimeouts = {};\n    reconnections = {};\n    onMessageHandlers = {};\n    _serializer = noneSerializer;\n    _afterNextPatchQueue = [];\n    _simulationInterval;\n    _patchInterval;\n    _locked = false;\n    _lockedExplicitly = false;\n    _maxClientsReached = false;\n    // this timeout prevents rooms that are created by one process, but no client\n    // ever had success joining into it on the specified interval.\n    _autoDisposeTimeout;\n    constructor(presence) {\n        this.presence = presence;\n        this._events.once('dispose', async () => {\n            try {\n                await this._dispose();\n            }\n            catch (e) {\n                debugAndPrintError(`onDispose error: ${(e && e.message || e || 'promise rejected')}`);\n            }\n            this._events.emit('disconnect');\n        });\n        this.setPatchRate(this.patchRate);\n    }\n    onAuth(client, options, request) {\n        return true;\n    }\n    hasReachedMaxClients() {\n        return (this.clients.length + Object.keys(this.reservedSeats).length) >= this.maxClients;\n    }\n    setSeatReservationTime(seconds) {\n        this.seatReservationTime = seconds;\n        return this;\n    }\n    hasReservedSeat(sessionId) {\n        return this.reservedSeats[sessionId] !== undefined;\n    }\n    setSimulationInterval(onTickCallback, delay = DEFAULT_SIMULATION_INTERVAL) {\n        // clear previous interval in case called setSimulationInterval more than once\n        if (this._simulationInterval) {\n            clearInterval(this._simulationInterval);\n        }\n        if (onTickCallback) {\n            this._simulationInterval = setInterval(() => {\n                this.clock.tick();\n                onTickCallback(this.clock.deltaTime);\n            }, delay);\n        }\n    }\n    setPatchRate(milliseconds) {\n        this.patchRate = milliseconds;\n        // clear previous interval in case called setPatchRate more than once\n        if (this._patchInterval) {\n            clearInterval(this._patchInterval);\n            this._patchInterval = undefined;\n        }\n        if (milliseconds !== null && milliseconds !== 0) {\n            this._patchInterval = setInterval(() => this.broadcastPatch(), milliseconds);\n        }\n    }\n    setState(newState) {\n        this.clock.start();\n        if ('_definition' in newState) {\n            this.setSerializer(new SchemaSerializer());\n        }\n        this._serializer.reset(newState);\n        this.state = newState;\n    }\n    setSerializer(serializer) {\n        this._serializer = serializer;\n    }\n    async setMetadata(meta) {\n        if (!this.listing.metadata) {\n            this.listing.metadata = meta;\n        }\n        else {\n            for (const field in meta) {\n                if (!meta.hasOwnProperty(field)) {\n                    continue;\n                }\n                this.listing.metadata[field] = meta[field];\n            }\n            // `MongooseDriver` workaround: persit metadata mutations\n            if ('markModified' in this.listing) {\n                this.listing.markModified('metadata');\n            }\n        }\n        if (this.internalState === RoomInternalState.CREATED) {\n            await this.listing.save();\n        }\n    }\n    async setPrivate(bool = true) {\n        this.listing.private = bool;\n        if (this.internalState === RoomInternalState.CREATED) {\n            await this.listing.save();\n        }\n    }\n    async lock() {\n        // rooms locked internally aren't explicit locks.\n        this._lockedExplicitly = (arguments[0] === undefined);\n        // skip if already locked.\n        if (this._locked) {\n            return;\n        }\n        this._locked = true;\n        await this.listing.updateOne({\n            $set: { locked: this._locked },\n        });\n        this._events.emit('lock');\n    }\n    async unlock() {\n        // only internal usage passes arguments to this function.\n        if (arguments[0] === undefined) {\n            this._lockedExplicitly = false;\n        }\n        // skip if already locked\n        if (!this._locked) {\n            return;\n        }\n        this._locked = false;\n        await this.listing.updateOne({\n            $set: { locked: this._locked },\n        });\n        this._events.emit('unlock');\n    }\n    send(client, messageOrType, messageOrOptions, options) {\n        console.warn('DEPRECATION WARNING: use client.send(...) instead of this.send(client, ...)');\n        client.send(messageOrType, messageOrOptions, options);\n    }\n    broadcast(typeOrSchema, messageOrOptions, options) {\n        const isSchema = (typeof (typeOrSchema) === 'object');\n        const opts = ((isSchema) ? messageOrOptions : options);\n        if (opts && opts.afterNextPatch) {\n            delete opts.afterNextPatch;\n            this._afterNextPatchQueue.push(['broadcast', arguments]);\n            return;\n        }\n        if (isSchema) {\n            this.broadcastMessageSchema(typeOrSchema, opts);\n        }\n        else {\n            this.broadcastMessageType(typeOrSchema, messageOrOptions, opts);\n        }\n    }\n    broadcastPatch() {\n        if (!this._simulationInterval) {\n            this.clock.tick();\n        }\n        if (!this.state) {\n            return false;\n        }\n        const hasChanges = this._serializer.applyPatches(this.clients, this.state);\n        // broadcast messages enqueued for \"after patch\"\n        this._dequeueAfterPatchMessages();\n        return hasChanges;\n    }\n    onMessage(messageType, callback) {\n        this.onMessageHandlers[messageType] = callback;\n        // returns a method to unbind the callback\n        return () => delete this.onMessageHandlers[messageType];\n    }\n    async disconnect() {\n        this.internalState = RoomInternalState.DISCONNECTING;\n        await this.listing.remove();\n        this.autoDispose = true;\n        const delayedDisconnection = new Promise((resolve) => this._events.once('disconnect', () => resolve()));\n        for (const reconnection of Object.values(this.reconnections)) {\n            reconnection.reject();\n        }\n        let numClients = this.clients.length;\n        if (numClients > 0) {\n            // clients may have `async onLeave`, room will be disposed after they're fulfilled\n            while (numClients--) {\n                this._forciblyCloseClient(this.clients[numClients], Protocol.WS_CLOSE_CONSENTED);\n            }\n        }\n        else {\n            // no clients connected, dispose immediately.\n            this._events.emit('dispose');\n        }\n        return await delayedDisconnection;\n    }\n    async ['_onJoin'](client, req) {\n        const sessionId = client.sessionId;\n        if (this.reservedSeatTimeouts[sessionId]) {\n            clearTimeout(this.reservedSeatTimeouts[sessionId]);\n            delete this.reservedSeatTimeouts[sessionId];\n        }\n        // clear auto-dispose timeout.\n        if (this._autoDisposeTimeout) {\n            clearTimeout(this._autoDisposeTimeout);\n            this._autoDisposeTimeout = undefined;\n        }\n        // get seat reservation options and clear it\n        const options = this.reservedSeats[sessionId];\n        delete this.reservedSeats[sessionId];\n        // share \"after next patch queue\" reference with every client.\n        client._afterNextPatchQueue = this._afterNextPatchQueue;\n        // bind clean-up callback when client connection closes\n        client.ref['onleave'] = this._onLeave.bind(this, client);\n        client.ref.once('close', client.ref['onleave']);\n        this.clients.push(client);\n        const reconnection = this.reconnections[sessionId];\n        if (reconnection) {\n            reconnection.resolve(client);\n        }\n        else {\n            try {\n                client.auth = await this.onAuth(client, options, req);\n                if (!client.auth) {\n                    throw new ServerError(ErrorCode.AUTH_FAILED, 'onAuth failed');\n                }\n                if (this.onJoin) {\n                    await this.onJoin(client, options, client.auth);\n                }\n            }\n            catch (e) {\n                spliceOne(this.clients, this.clients.indexOf(client));\n                // make sure an error code is provided.\n                if (!e.code) {\n                    e.code = ErrorCode.APPLICATION_ERROR;\n                }\n                throw e;\n            }\n            finally {\n                // remove seat reservation\n                delete this.reservedSeats[sessionId];\n            }\n        }\n        // emit 'join' to room handler\n        this._events.emit('join', client);\n        // allow client to send messages after onJoin has succeeded.\n        client.ref.on('message', this._onMessage.bind(this, client));\n        // confirm room id that matches the room name requested to join\n        client.raw(getMessageBytes[Protocol.JOIN_ROOM](this._serializer.id, this._serializer.handshake && this._serializer.handshake()));\n    }\n    allowReconnection(previousClient, seconds = Infinity) {\n        if (this.internalState === RoomInternalState.DISCONNECTING) {\n            this._disposeIfEmpty(); // gracefully shutting down\n            throw new Error('disconnecting');\n        }\n        const sessionId = previousClient.sessionId;\n        this._reserveSeat(sessionId, true, seconds, true);\n        // keep reconnection reference in case the user reconnects into this room.\n        const reconnection = new Deferred();\n        this.reconnections[sessionId] = reconnection;\n        if (seconds !== Infinity) {\n            // expire seat reservation after timeout\n            this.reservedSeatTimeouts[sessionId] = setTimeout(() => reconnection.reject(false), seconds * 1000);\n        }\n        const cleanup = () => {\n            delete this.reservedSeats[sessionId];\n            delete this.reconnections[sessionId];\n            delete this.reservedSeatTimeouts[sessionId];\n        };\n        reconnection.\n            then((newClient) => {\n            newClient.auth = previousClient.auth;\n            previousClient.ref = newClient.ref; // swap \"ref\" for convenience\n            previousClient.state = ClientState.RECONNECTED;\n            clearTimeout(this.reservedSeatTimeouts[sessionId]);\n            cleanup();\n        }).\n            catch(() => {\n            cleanup();\n            this.resetAutoDisposeTimeout();\n        });\n        return reconnection;\n    }\n    resetAutoDisposeTimeout(timeoutInSeconds = 1) {\n        clearTimeout(this._autoDisposeTimeout);\n        if (!this.autoDispose) {\n            return;\n        }\n        this._autoDisposeTimeout = setTimeout(() => {\n            this._autoDisposeTimeout = undefined;\n            this._disposeIfEmpty();\n        }, timeoutInSeconds * 1000);\n    }\n    broadcastMessageSchema(message, options = {}) {\n        const encodedMessage = getMessageBytes[Protocol.ROOM_DATA_SCHEMA](message);\n        let numClients = this.clients.length;\n        while (numClients--) {\n            const client = this.clients[numClients];\n            if (options.except !== client) {\n                client.enqueueRaw(encodedMessage);\n            }\n        }\n    }\n    broadcastMessageType(type, message, options = {}) {\n        const encodedMessage = getMessageBytes[Protocol.ROOM_DATA](type, message);\n        let numClients = this.clients.length;\n        while (numClients--) {\n            const client = this.clients[numClients];\n            if (options.except !== client) {\n                client.enqueueRaw(encodedMessage);\n            }\n        }\n    }\n    sendFullState(client) {\n        client.enqueueRaw(getMessageBytes[Protocol.ROOM_STATE](this._serializer.getFullState(client)));\n    }\n    _dequeueAfterPatchMessages() {\n        const length = this._afterNextPatchQueue.length;\n        if (length > 0) {\n            for (let i = 0; i < length; i++) {\n                const [target, args] = this._afterNextPatchQueue[i];\n                if (target === \"broadcast\") {\n                    this.broadcast.apply(this, args);\n                }\n                else {\n                    target.raw.apply(target, args);\n                }\n            }\n            // new messages may have been added in the meantime,\n            // let's splice the ones that have been processed\n            this._afterNextPatchQueue.splice(0, length);\n        }\n    }\n    async _reserveSeat(sessionId, joinOptions = true, seconds = this.seatReservationTime, allowReconnection = false) {\n        if (!allowReconnection && this.hasReachedMaxClients()) {\n            return false;\n        }\n        this.reservedSeats[sessionId] = joinOptions;\n        if (!allowReconnection) {\n            await this._incrementClientCount();\n            this.reservedSeatTimeouts[sessionId] = setTimeout(async () => {\n                delete this.reservedSeats[sessionId];\n                delete this.reservedSeatTimeouts[sessionId];\n                await this._decrementClientCount();\n            }, seconds * 1000);\n            this.resetAutoDisposeTimeout(seconds);\n        }\n        return true;\n    }\n    _disposeIfEmpty() {\n        const willDispose = (this.autoDispose &&\n            this._autoDisposeTimeout === undefined &&\n            this.clients.length === 0 &&\n            Object.keys(this.reservedSeats).length === 0);\n        if (willDispose) {\n            this._events.emit('dispose');\n        }\n        return willDispose;\n    }\n    async _dispose() {\n        let userReturnData;\n        if (this.onDispose) {\n            userReturnData = this.onDispose();\n        }\n        if (this._patchInterval) {\n            clearInterval(this._patchInterval);\n            this._patchInterval = undefined;\n        }\n        if (this._simulationInterval) {\n            clearInterval(this._simulationInterval);\n            this._simulationInterval = undefined;\n        }\n        if (this._autoDisposeTimeout) {\n            clearInterval(this._autoDisposeTimeout);\n            this._autoDisposeTimeout = undefined;\n        }\n        // clear all timeouts/intervals + force to stop ticking\n        this.clock.clear();\n        this.clock.stop();\n        return await (userReturnData || Promise.resolve());\n    }\n    _onMessage(client, bytes) {\n        // skip if client is on LEAVING state.\n        if (client.state === ClientState.LEAVING) {\n            return;\n        }\n        const it = { offset: 0 };\n        const code = decode.uint8(bytes, it);\n        if (!bytes) {\n            debugAndPrintError(`${this.roomName} (${this.roomId}), couldn't decode message: ${bytes}`);\n            return;\n        }\n        if (code === Protocol.ROOM_DATA) {\n            const messageType = (decode.stringCheck(bytes, it))\n                ? decode.string(bytes, it)\n                : decode.number(bytes, it);\n            let message;\n            try {\n                message = (bytes.length > it.offset)\n                    ? msgpack.decode(bytes.slice(it.offset, bytes.length))\n                    : undefined;\n            }\n            catch (e) {\n                debugAndPrintError(e);\n                return;\n            }\n            if (this.onMessageHandlers[messageType]) {\n                this.onMessageHandlers[messageType](client, message);\n            }\n            else if (this.onMessageHandlers['*']) {\n                this.onMessageHandlers['*'](client, messageType, message);\n            }\n            else {\n                debugAndPrintError(`onMessage for \"${messageType}\" not registered.`);\n            }\n        }\n        else if (code === Protocol.JOIN_ROOM) {\n            // join room has been acknowledged by the client\n            client.state = ClientState.JOINED;\n            // send current state when new client joins the room\n            if (this.state) {\n                this.sendFullState(client);\n            }\n            // dequeue messages sent before client has joined effectively (on user-defined `onJoin`)\n            if (client._enqueuedMessages.length > 0) {\n                client._enqueuedMessages.forEach((enqueued) => client.raw(enqueued));\n            }\n            delete client._enqueuedMessages;\n        }\n        else if (code === Protocol.LEAVE_ROOM) {\n            this._forciblyCloseClient(client, Protocol.WS_CLOSE_CONSENTED);\n        }\n    }\n    _forciblyCloseClient(client, closeCode) {\n        // stop receiving messages from this client\n        client.ref.removeAllListeners('message');\n        // prevent \"onLeave\" from being called twice if player asks to leave\n        client.ref.removeListener('close', client.ref['onleave']);\n        // only effectively close connection when \"onLeave\" is fulfilled\n        this._onLeave(client, closeCode).then(() => client.leave(Protocol.WS_CLOSE_NORMAL));\n    }\n    async _onLeave(client, code) {\n        const success = spliceOne(this.clients, this.clients.indexOf(client));\n        // call 'onLeave' method only if the client has been successfully accepted.\n        if (success && this.onLeave) {\n            try {\n                client.state = ClientState.LEAVING;\n                await this.onLeave(client, (code === Protocol.WS_CLOSE_CONSENTED));\n            }\n            catch (e) {\n                debugAndPrintError(`onLeave error: ${(e && e.message || e || 'promise rejected')}`);\n            }\n        }\n        if (client.state !== ClientState.RECONNECTED) {\n            // try to dispose immediatelly if client reconnection isn't set up.\n            const willDispose = await this._decrementClientCount();\n            this._events.emit('leave', client, willDispose);\n        }\n    }\n    async _incrementClientCount() {\n        // lock automatically when maxClients is reached\n        if (!this._locked && this.hasReachedMaxClients()) {\n            this._maxClientsReached = true;\n            this.lock.call(this, true);\n        }\n        await this.listing.updateOne({\n            $inc: { clients: 1 },\n            $set: { locked: this._locked },\n        });\n    }\n    async _decrementClientCount() {\n        const willDispose = this._disposeIfEmpty();\n        if (this.internalState === RoomInternalState.DISCONNECTING) {\n            return;\n        }\n        // unlock if room is available for new connections\n        if (!willDispose) {\n            if (this._maxClientsReached && !this._lockedExplicitly) {\n                this._maxClientsReached = false;\n                this.unlock.call(this, true);\n            }\n            // update room listing cache\n            await this.listing.updateOne({\n                $inc: { clients: -1 },\n                $set: { locked: this._locked },\n            });\n        }\n        return willDispose;\n    }\n}\n\nexport { DEFAULT_SEAT_RESERVATION_TIME, Room, RoomInternalState };\n//# sourceMappingURL=Room.mjs.map\n"],"names":[],"mappings":";;;;;;;;;AAesC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,8BAA8B,IAAI,EAAE,EAAE;AAC5F,IAAC,kBAAkB;AACtB,CAAC,UAAU,iBAAiB,EAAE;AAC9B,IAAI,iBAAiB,CAAC,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;AACtE,IAAI,iBAAiB,CAAC,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;AACpE,IAAI,iBAAiB,CAAC,iBAAiB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe,CAAC;AAChF,CAAC,EAAE,iBAAiB,KAAK,iBAAiB,GAAG,EAAE,CAAC,CAAC;;;;"}